package webvtt

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"bitbucket.org/airenas/list/src/tools/internal/pkg/lattice"
)

type splitFuncType func(words []*lattice.Word) [][]int

var splitFunc splitFuncType

func init() {
	splitFunc = splitText
}

// Line for webvtt line
type Line struct {
	Speaker string
	words   []*lattice.Word
	to      time.Duration
	From    time.Duration
}

// Header constructs WebVTT header
func Header(str string) string {
	if str != "" {
		return fmt.Sprintf("WEBVTT - %s\n", str)
	}
	return "WEBVTT - Generated by LKSSAIS\n"
}

type tdata struct {
	res     []*Line
	speaker string
	words   []*lattice.Word
	to      time.Duration
}

// Extract get line slice from lattice
func Extract(data []*lattice.Part) []*Line {
	td := &tdata{res: make([]*Line, 0)}
	for _, p := range data {
		if p.Speaker != td.speaker {
			write(td)
			td.speaker = p.Speaker
		}
		for _, w := range p.Words {
			if w.Main == lattice.MainInd {
				if w.Text != lattice.SilWord {
					if len(td.words) > 0 && (lattice.Duration(w.From)-td.to) > 500*time.Millisecond {
						write(td)
					}
					add(td, w)
				}
			}
		}
	}
	write(td)
	return td.res
}

func write(td *tdata) {
	if len(td.words) > 0 {
		ws := splitFunc(td.words)
		for _, s := range ws {
			ln := &Line{words: td.words[s[0]:s[1]], to: lattice.Duration(td.words[s[1]-1].To),
				From: lattice.Duration(td.words[s[0]].From)}
			td.res = append(td.res, ln)
		}
	}
	td.words = nil
}

func add(td *tdata, w *lattice.Word) {
	td.to = lattice.Duration(w.To)
	td.words = append(td.words, w)
}

// WriteTo writes lines to result builder
func WriteTo(sb *strings.Builder, lines []*Line) {
	for _, l := range lines {
		WriteLineTo(sb, l, "")
	}
}

// WriteLineTo writes line to result builder with speaker
func WriteLineTo(sb *strings.Builder, line *Line, speaker string) {
	writePhrase(sb, line.words, speaker)
}

func writePhrase(sb *strings.Builder, words []*lattice.Word, speaker string) {
	l := len(words)
	sb.WriteString("\n")
	sb.WriteString(asString(lattice.Duration(words[0].From)))
	sb.WriteString(" --> ")
	sb.WriteString(asString(lattice.Duration(words[l-1].To)))
	sb.WriteString("\n")
	writeSpeaker(sb, speaker)
	writeWords(sb, words)
	sb.WriteString("\n")
}

func writeWords(sb *strings.Builder, words []*lattice.Word) {
	sep := ""
	for _, w := range words {
		writeWord(sb, asHTML(strings.Join(w.Words, " ")), sep)
		sep = writePunct(sb, w.Punct)
	}
}

func writeSpeaker(res *strings.Builder, sp string) {
	if sp != "" {
		res.WriteString(fmt.Sprintf("<v %s>", asHTML(sp)))
	}
}

func writeWord(res *strings.Builder, word, sep string) string {
	res.WriteString(sep + word)
	return " "
}

func writePunct(res *strings.Builder, punct string) string {
	if punct == "-" {
		res.WriteString(" ")
	}
	res.WriteString(punct)
	return " "
}

func asHTML(s string) string {
	//return html.EscapeString(s)
	return strings.ReplaceAll(strings.ReplaceAll(s, "<", "&lt;"), ">", "&gt;")
}

func asString(d time.Duration) string {
	res := ""
	ms := d.Milliseconds()
	tv := int64(ms) / time.Hour.Milliseconds()
	if tv > 0 {
		res += padString(tv, 2) + ":"
	}
	ms = ms % time.Hour.Milliseconds()
	tv = ms / time.Minute.Milliseconds()
	res += padString(tv, 2) + ":"
	ms = ms % time.Minute.Milliseconds()
	tv = ms / time.Second.Milliseconds()
	res += padString(tv, 2) + "."
	ms = ms % time.Second.Milliseconds()
	res += padString(ms, 3)
	return res
}

func padString(v int64, l int) string {
	res := strconv.Itoa(int(v))
	for len(res) < l {
		res = "0" + res
	}
	return res
}
