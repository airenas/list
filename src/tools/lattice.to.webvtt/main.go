package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"bitbucket.org/airenas/list/src/tools/internal/pkg/lattice"
	"bitbucket.org/airenas/list/src/tools/internal/pkg/util"
	"github.com/pkg/errors"
)

type splitFuncType func(words []*lattice.Word) [][]int

var splitFunc splitFuncType

func init() {
	splitFunc = splitText
}


func main() {
	log.SetOutput(os.Stderr)
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage of %s: [input-file | stdin] [output-file | stdout]\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	f, err := util.NewReadWrapper(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	destination, err := util.NewWriteWrapper(flag.Arg(1))
	if err != nil {
		log.Fatal(err)
	}
	defer destination.Close()

	data, err := lattice.Read(f)
	if err != nil {
		log.Fatal(errors.Wrap(err, "Can't read lattice"))
	}
	_, err = destination.WriteString(getHeader())
	text := getWebVTT(data)
	_, err = destination.WriteString(text)
	if err != nil {
		log.Fatal(errors.Wrap(err, "Can't write result lattice"))
	}
	log.Print("Done generation")
}

type tdata struct {
	sb      strings.Builder
	speaker string
	words   []*lattice.Word
	to      time.Duration
}

func getHeader() string {
	return "WEBVTT - Generated by LKSSAIS\n"
}

func getWebVTT(data []*lattice.Part) string {
	td := &tdata{}
	for _, p := range data {
		if p.Speaker != td.speaker {
			write(td)
			td.speaker = p.Speaker
		}
		for _, w := range p.Words {
			if w.Main == lattice.MainInd {
				if w.Text != lattice.SilWord {
					if len(td.words) > 0 && (lattice.Duration(w.From)-td.to) > 500*time.Millisecond {
						write(td)
					}
					add(td, w)
				}
			}
		}
	}
	write(td)
	return td.sb.String()
}

func write(td *tdata) {
	if len(td.words) > 0 {
		ws := splitFunc(td.words)
		for _, s := range ws {
			writePhrase(&td.sb, td.words[s[0]:s[1]])
		}
	}
	td.words = td.words[:0]
}

func writePhrase(sb *strings.Builder, words []*lattice.Word) {
	l := len(words)
	sb.WriteString("\n")
	sb.WriteString(asString(lattice.Duration(words[0].From)))
	sb.WriteString(" --> ")
	sb.WriteString(asString(lattice.Duration(words[l-1].To)))
	sb.WriteString("\n")
	writeWords(sb, words)
	sb.WriteString("\n")
}

func writeWords(sb *strings.Builder, words []*lattice.Word) {
	sep := ""
	for _, w := range words{
		sep = writeWord(sb, strings.Join(w.Words, " "), sep)
		sep = writePunct(sb, w.Punct)
	}
}

func add(td *tdata, w *lattice.Word) {
	td.to = lattice.Duration(w.To)
	td.words = append(td.words, w)
}

func writeWord(res *strings.Builder, word, sep string) string {
	res.WriteString(sep + word)
	return " "
}

func writePunct(res *strings.Builder, punct string) string {
	if punct == "-" {
		res.WriteString(" ")
	}
	res.WriteString(punct)
	return " "
}

func asString(d time.Duration) string {
	res := ""
	ms := d.Milliseconds()
	tv := int64(ms) / time.Hour.Milliseconds()
	if tv > 0 {
		res += padString(tv, 2) + ":"
	}
	ms = ms % time.Hour.Milliseconds()
	tv = ms / time.Minute.Milliseconds()
	res += padString(tv, 2) + ":"
	ms = ms % time.Minute.Milliseconds()
	tv = ms / time.Second.Milliseconds()
	res += padString(tv, 2) + "."
	ms = ms % time.Second.Milliseconds()
	res += padString(ms, 3)
	return res
}

func padString(v int64, l int) string {
	res := strconv.Itoa(int(v))
	for len(res) < l {
		res = "0" + res
	}
	return res
}
